---
title: JVM与GC调优(三)-内存结构篇
index_img: /img/default.png
banner_img: /img/default.png
date: 2022-09-25 13:08:54
tags:
categories:
description:

---

了解内存结构中相关信息，程序计数器、虚拟器栈、本地方法和本地接口栈、堆、方法区

<!-- more -->

## 程序计数器（Program Counter Register）

> PC 寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码

- 它是一块很小的内存空间，几乎可以忽略不记。也是运算速度最快的存储区域。

- 在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。

- 任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行 native方法，则是未指定值（undefined）（因为PC寄存器是java层面的，本地方法栈是C/C++层面的）。

- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成；

- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令；

- 它是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

### 为什么要设置成 线程私有的 ？

CPU需要不停的切换线程，在切换回来的时候，A线程的PC寄存器里就记录了 A线程执行到哪里了 B线程的PC寄存器里就记录了 B线程执行到哪里了，所以需要 是线程私有的。

## 栈（虚拟机栈）的理解

Java虚拟机分堆区、栈区、方法区

### 概念：

> Java 虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应这一次次的 Java 方法调用。

### 作用：

> 主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果、并参与方法的调用和返回

### 特点：

- Java虚拟机栈也是`线程私有`的，它的生命周期与线程相同（随线程而生，随线程而灭）
- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
　-  如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常；

　　（当前大部分JVM都可以动态扩展，只不过JVM规范也允许固定长度的虚拟机栈）

 -  Java虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时会创建一个栈帧。

### 相关问题

栈 jdk5以后默认都是1M，栈空间比较小

#### 栈中存在垃圾回收吗？

栈中不存在垃圾回收

#### 栈中可能抛出的异常是什么？

> Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。
>

- 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError 异常。

- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutOfMemoryError 异常。

#### 如何设置栈内存的大小？

-Xss size (即：-XX:ThreadStackSize) 一般默认为512k-1024k，取决于操作系统。

## 栈的单位：栈帧（Stack Frame）

> 每个线程都有自己的栈，栈中的数据都是以**栈帧**（Stack Frame）的格式存在

**方法与栈帧的关系：**

栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息

![image-20220928204912987](https://file.hyqup.cn/img/image-20220928204912987.png)

**栈帧的内部结构：**

![image-20220928205653573](https://file.hyqup.cn/img/image-20220928205653573.png)

### 栈的FILO原理

![image-20220928211031108](https://file.hyqup.cn/img/image-20220928211031108.png)

JVM直接对Java栈的操作只有两个：

- 每个方法执行，伴随着压栈（push）
- 执行结束后的出栈（pop）

遵循`先进后出`、`后进先出`原则

### 栈帧中的信息

每个栈帧存在以下信息

- `局部变量表`
- `操作数栈`
- `动态链接`
- `方法返回地址`
- 一些`附加信息`

### *局部变量表（本地变量表【Local veriables】）

> 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量

这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型

![image-20220928220835279](https://file.hyqup.cn/img/image-20220928220835279.png)

注意：

1、`非静态`方法的话 会有 `this` 变量 在 index 为0 的位置

2、`double`和`long` 占据两个 slot位 ，一个是 4位

3、栈帧当中的局部变量表的槽位是可以被`重复利用`的，出了`作用域`就会被`销毁`，后面定义的变量就会占据被销毁的变量的位置

4、局部变量表中的变量也是重要的`垃圾回收根节点`，只要被局部变量表中直接或间接引用的对象都不会被回收

### *操作数栈（Operaand Stack）

> 也叫`表达式栈`，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即`入栈(push)`/`出栈(pop)`。并非采用索引访问。

#### 作用：

**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间；**

```java
public void testAddOperation(){
    byte i = 15;
    int j = 8;
    int k = i + j;
}
```

![image-20220928224543209](https://file.hyqup.cn/img/image-20220928224543209.png)

![image-20220928224548943](https://file.hyqup.cn/img/image-20220928224548943.png)

![image-20220928224554113](https://file.hyqup.cn/img/image-20220928224554113.png)

![image-20220928224600714](https://file.hyqup.cn/img/image-20220928224600714.png)

![image-20220928224605206](https://file.hyqup.cn/img/image-20220928224605206.png)

![image-20220928224610548](https://file.hyqup.cn/img/image-20220928224610548.png)

![image-20220928224618969](https://file.hyqup.cn/img/image-20220928224618969.png)

![image-20220928224622772](https://file.hyqup.cn/img/image-20220928224622772.png)

### 动态链接（Dynamic Linking）

指向运行时常量池的方法引用

- 每一个栈帧内部包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接
- 在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**。

