---
title: JVM与GC调优(四)-对象的生命周期和垃圾回收GC篇
index_img: /img/default.png
banner_img: /img/default.png
date: 2023-03-12 22:45:15
tags:
categories:
description:
---





Java对象的生命周期，对象从创建过程，到内存中分配方式，如何分配以及何时进入老年代相关。JVM垃圾回收

<!-- more -->

# 对象的生命周期

##  对象创建的流程

### 创建流程

![对象创建过程](http://file.hyqup.cn/img/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png)

### 对象内存的分配方式

内存分配的方法有两种：不同垃圾收集器不一样

- 指针碰撞(Bump the Pointer)

  > 内存地址是连续的（新生代），Serial 和ParNew 收集器

- 空闲列表(Free List)

  > 内存地址不连续（老年代），CMS 收集器和 Mark-Sweep 收集器

### 对象内存分配的安全问题

在并发情况下， 可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况

**在JVM中有两种解决办法**

- CAS 是**乐观锁**的一种实现方式。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
- TLAB**本地线程分配缓冲**(Thread Local Allocation Buffer即TLAB)：为每一个线程预先分配一块内存

###  对象怎样才会进入老年代？

对象的分配对象情况如下

- **新生代**：新对象大多数都默认进入新生代的Eden区。伊甸园（希腊神话）

- **老年代**（四种情况）：

  - **存活年龄太大，默认超过15次【`-XX:MaxTenuringThreshold`】**

  - **动态年龄判断**，MinorGC之后，发现Survivor区中的一批对象的总大小大于了这块Survivor区

    的50%，那么就会将此时大于等于这批对象年龄最大值的所有对象，直接进入老年代

  - **大对象直接进入老年代**，前提是Serial和ParNew收集器

  - MinorGC后，存活对象太多无法放入Survivor

**空间担保机制**

> 当新生代无法分配内存的时候，我们想把新生代的**老对象**转移到老年代，然后把**新对象**放入腾空的新生代。此种机制我们称之为**内存担保**。

## 对象的内存布局

> 堆内存中，一个对象在内存中存储的布局可以分为三块区域

- **对象头（Header）**Java对象头占8byte。如果是数组则占12byte。因为JVM里数组size需要使用

  4byte存储

  - **标记字段**MarkWord
    - 用于存储对象自身的运行时数据，它是synchronized实现轻量级锁和偏向锁的关键
    - 默认存储：对象HashCode、GC分代年龄、锁状态等等信息
    - 锁标志位的变化，存储数据发生变化
  - **类型指针**KlassPoint
    - 是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
    - 开启指针压缩存储空间4byte，不开启8byte
    - JDK1.6+默认开启
  - **数组长度**
    - 如果对象是数组，则记录数组长度，占4个byte，如果对象不是数组则不存在
  - **对齐填充**
    - 保证数组的大小永远是8byte的整数倍

- **实例数据（**Instance Data）

  - 生成对象的时候，对象的非静态成员变量也会存入堆空间

- **对齐填充（**Padding**）**

  - JVM内对象都采用8byte对齐，不够8byte的会自动补齐

## 如何访问一个对象

- **句柄**：稳定，对象被移动只要修改句柄中的地址
- **直接指针**：访问速度快，节省了一次指针定位的开销

#  JVM垃圾收集器

## 概述

**什么是垃圾？**

> 在内存中，没有被引用的对象就是垃圾

## 如何找到这个垃圾？

主要是2种：**引用计数法**和**根可达算法**

- **引用计数法（`Reference Counting`）**

  - **引用计数算法不能解决循环引用问题**
- **根可达算法（`GCRoots Tracing`）**

  - 通过一系列的名为`GCRoot`的对象作为起始点，从这些节点开始向下搜索，搜索所走过的

    路径称为**引用链（`Reference Chain`）**，当一个对象到GCRoot没有任何引用链相连时，则证明此对象是不可用的，也就是不可达的

**可作`GCRoots`的对象**

- 虚拟机栈中，栈帧的本地变量表引用的对象
- 方法区中，类静态属性引用的对象
- 方法区中，常量引用的对象
- 本地方法栈中，JNl引用的对象、

## 回收过程

> 垃圾对象在死亡前至少经历两次标记

**第一次标记**：如果对象可达性分析后，发现没有与GC Roots相连接的引用链，那它将会被第一次标记

**第二次标记**：第一次标记后，接着会进行一次筛选。筛选条件：此对象是否有必要执行finalize() 方法。在 finalize() 方法中没有重新与引用链建立关联关系的，将被进行第二次标记

## 对象引用
