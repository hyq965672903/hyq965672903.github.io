{"title":"Java并发多线程与高并发(五)-线程安全策略","slug":"Java并发多线程与高并发(五)-线程安全策略","date":"2021-04-28T15:40:44.000Z","updated":"2024-04-22T07:21:14.887Z","comments":true,"path":"api/articles/Java并发多线程与高并发(五)-线程安全策略.json","excerpt":"本文讲述在Java中经常会使用一些对象，集合。单线程下没问题，在多线程下就会出现问题，我们对这些对象在使用的时候如何去做来保证线程安全","covers":null,"content":"<p>本文讲述在Java中经常会使用一些对象，集合。单线程下没问题，在多线程下就会出现问题，我们对这些对象在使用的时候如何去做来保证线程安全</p>\n<span id=\"more\"></span>\n\n<h2 id=\"不可变对象\"><a href=\"#不可变对象\" class=\"headerlink\" title=\"不可变对象\"></a>不可变对象</h2><h3 id=\"不可变对象需要满足的条件：\"><a href=\"#不可变对象需要满足的条件：\" class=\"headerlink\" title=\"不可变对象需要满足的条件：\"></a>不可变对象需要满足的条件：</h3><ul>\n<li>对象创建以后其状态就不能修改</li>\n<li>对象所有域都是final类型</li>\n<li>对象是正确创建的（在对象创建期间，this引用没有逸出）</li>\n</ul>\n<p>简而言之就是将类声明为final，将所有的成员声明为私有的，对变量不提供set方法。将所有可变的成员声明为final。在get方法中不返回对象本身，而是克隆对象的拷贝。（可参考String类）。</p>\n<h3 id=\"final关键字：类、方法、变量\"><a href=\"#final关键字：类、方法、变量\" class=\"headerlink\" title=\"final关键字：类、方法、变量\"></a>final关键字：类、方法、变量</h3><ul>\n<li><p>修饰类：不能被继承，<strong>final类中的方法会被隐式的被指定为final方法</strong></p>\n</li>\n<li><p>修饰方法：1、锁定方法被继承类修改；2、效率。<strong>一个类的private方法会被隐式指定为final类型</strong></p>\n</li>\n<li><p>修饰变量：基本数据类型变量、引用类型变量。<strong>基本数据类型数值一旦被初始就不能被修改了，引用类型在对其初始化之后便不能指向另外一个<em>对象</em></strong>，<em>（注意）引用类型的值是可修改的</em></p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">cn<span class=\"token punctuation\">.</span>hyqup<span class=\"token punctuation\">.</span>concurrency<span class=\"token punctuation\">.</span>immutable</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">HashMap</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Map</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * Copyright © 2021灼华. All rights reserved.\n *\n * @author create by hyq\n * @version 1.0\n * @date 2021/5/15\n * @description:\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ImmutableExample1</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Integer</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">String</span> b <span class=\"token operator\">=</span> <span class=\"token string\">\"2\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span>\n        c<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        c<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token comment\">//        a=11; 不可以修改，编译时候就不允许</span>\n<span class=\"token comment\">//        b=\"22\"; 不可以修改，编译时候就不允许</span>\n<span class=\"token comment\">//        c=new HashMap&lt;>(); 不可以指向新的对象，编译时候就不允许</span>\n        c<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 引用类型但是可以修改值</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li>\n</ul>\n<h3 id=\"不可变引用数据类型\"><a href=\"#不可变引用数据类型\" class=\"headerlink\" title=\"不可变引用数据类型\"></a>不可变引用数据类型</h3><ul>\n<li><p>java提供：Collections.unmodifiableXXX:Collection、List、Set、Map…</p>\n</li>\n<li><p>guava提供:ImmutableXXX：Collection、List、Set、Map…</p>\n</li>\n</ul>\n<h2 id=\"线程封闭\"><a href=\"#线程封闭\" class=\"headerlink\" title=\"线程封闭\"></a>线程封闭</h2><p>当访问共享的可变数据时，通常需要同步。一种避免同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步，这种技术称为线程封闭（thread  confinement）,ThreadLocal</p>\n<h2 id=\"线程不安全的类与写法\"><a href=\"#线程不安全的类与写法\" class=\"headerlink\" title=\"线程不安全的类与写法\"></a>线程不安全的类与写法</h2><ul>\n<li><p>StringBuilder和StringBuffer两种字符串拼接类</p>\n<ul>\n<li>StringBuilder 线程不安全，但效率高</li>\n<li>StringBuffer 线程安全，但效率低</li>\n</ul>\n</li>\n<li><p>SimpleDateFormate</p>\n<p>多线程下不安全，可以采用jodaTime来实现</p>\n</li>\n<li><p>ArrayList,HashSet，HashMap等集合（使用同步容器解决）</p>\n<ul>\n<li>ArrayList</li>\n<li>HashSet</li>\n<li>HashMap</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"同步容器\"><a href=\"#同步容器\" class=\"headerlink\" title=\"同步容器\"></a>同步容器</h2><p>使用synchronized来实现</p>\n<ul>\n<li><p>ArrayList-&gt;Vector,Stack</p>\n</li>\n<li><p>HashMap-&gt;HashTable(key、value不能为null)</p>\n</li>\n<li><p>Collections.synchronizedXXX(List、Set、Map)</p>\n</li>\n</ul>\n<h2 id=\"并发容器及安全共享策略\"><a href=\"#并发容器及安全共享策略\" class=\"headerlink\" title=\"并发容器及安全共享策略\"></a>并发容器及安全共享策略</h2><p>同步容器的安全性得以保证，但是性能不是很好，所以Java中通常使用并发容器来替代同步容器，来完成并发下的工作</p>\n<h3 id=\"并发容器J-U-C-java-util-concurrent\"><a href=\"#并发容器J-U-C-java-util-concurrent\" class=\"headerlink\" title=\"并发容器J.U.C(java.util.concurrent)\"></a>并发容器J.U.C(java.util.concurrent)</h3><h4 id=\"ArrayList-–-CopyOnWriteArrayList\"><a href=\"#ArrayList-–-CopyOnWriteArrayList\" class=\"headerlink\" title=\"ArrayList –&gt; CopyOnWriteArrayList\"></a>ArrayList –&gt; CopyOnWriteArrayList</h4><h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念 :\"></a>概念 :</h5><p>简单的讲就是写操作时赋值,当有新元素添加到CopyOnWriteArrayList时,它先从原有的数组里边Copy一份出来然后在新的数组上做些操作,操作完成以后在将引用指向新的数组;CopyOnWriteArrayList所有的操作都是在锁的保护下进行的,这样做的目的主要是为了在多线程并发做add操作的时候复制出多个副本出来导致数据混乱</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点 :\"></a>缺点 :</h5><ul>\n<li><p>由于是copy的操作所以比较消耗内存,如果元素的内容较多的时候可能会触发GC</p>\n</li>\n<li><p>不能用于实时读的场景,它比较适合读多写少的场景(因为写的时候会复制新集合)</p>\n</li>\n</ul>\n<h5 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想 :\"></a>思想 :</h5><ul>\n<li>读写分离</li>\n<li>最终一致性</li>\n<li>另外开辟空间解决并发冲突</li>\n</ul>\n<h4 id=\"HashSet-–-CopyOnWriteArraySet和TreeSet-–-ConcurrentSkipListSet\"><a href=\"#HashSet-–-CopyOnWriteArraySet和TreeSet-–-ConcurrentSkipListSet\" class=\"headerlink\" title=\"HashSet –&gt; CopyOnWriteArraySet和TreeSet –&gt; ConcurrentSkipListSet\"></a>HashSet –&gt; CopyOnWriteArraySet和TreeSet –&gt; ConcurrentSkipListSet</h4><ul>\n<li>CopyOnWriteArraySet 线程安全，底层实现是使用CopyOnWriteArrayList，特性类似CopyOnWriteArrayList，适合于<strong>数据量小</strong>的时候，只读操作大于可变操作的时候</li>\n<li>ConcurrentSkipListSet 是jdk6新增的类，和TreeSet 一样支持自然排序，并且在构造的时候自己定义比较器。基于Map集合的，在多线程环境下，（set 、add、remove）等方法都是线程安全的，但是对于批量操作（addAll、removeAll等）并不能保证以原子方式进行操作，原因是底层还是（add、remove 等）批量操作的时候只能保证每一次的操作是原子性的，不能保证每一次操作不能被其他操作打断。所以<strong>使用批量操作的时候可能需要手动处理一下（加锁）</strong></li>\n</ul>\n<h4 id=\"HashMap-–-ConcurrentHashMap-和-TreeMap-–-ConcurrentSkipListMap\"><a href=\"#HashMap-–-ConcurrentHashMap-和-TreeMap-–-ConcurrentSkipListMap\" class=\"headerlink\" title=\"HashMap –&gt; ConcurrentHashMap 和 TreeMap –&gt; ConcurrentSkipListMap\"></a>HashMap –&gt; ConcurrentHashMap 和 TreeMap –&gt; ConcurrentSkipListMap</h4><ul>\n<li><p>ConcurrentHashMap  不允许空值，ConcurrentHashMap针对读操作多了特别多的优化,具有特别高的并发性</p>\n</li>\n<li><p>ConcurrentSkipListMap 底层是使用SkipList这种跳表的结构实现的</p>\n<p>对比：ConcurrentHashMap  存取效率高于ConcurrentSkipListMap 。但是：</p>\n<p>1、ConcurrentSkipListMap 的key是有序的 2、支持更高的并发</p>\n</li>\n</ul>\n<p>总结：这里只涉及到了一小部分J.U.C的知识点</p>\n","more":"<h2 id=\"不可变对象\"><a href=\"#不可变对象\" class=\"headerlink\" title=\"不可变对象\"></a>不可变对象</h2><h3 id=\"不可变对象需要满足的条件：\"><a href=\"#不可变对象需要满足的条件：\" class=\"headerlink\" title=\"不可变对象需要满足的条件：\"></a>不可变对象需要满足的条件：</h3><ul>\n<li>对象创建以后其状态就不能修改</li>\n<li>对象所有域都是final类型</li>\n<li>对象是正确创建的（在对象创建期间，this引用没有逸出）</li>\n</ul>\n<p>简而言之就是将类声明为final，将所有的成员声明为私有的，对变量不提供set方法。将所有可变的成员声明为final。在get方法中不返回对象本身，而是克隆对象的拷贝。（可参考String类）。</p>\n<h3 id=\"final关键字：类、方法、变量\"><a href=\"#final关键字：类、方法、变量\" class=\"headerlink\" title=\"final关键字：类、方法、变量\"></a>final关键字：类、方法、变量</h3><ul>\n<li><p>修饰类：不能被继承，<strong>final类中的方法会被隐式的被指定为final方法</strong></p>\n</li>\n<li><p>修饰方法：1、锁定方法被继承类修改；2、效率。<strong>一个类的private方法会被隐式指定为final类型</strong></p>\n</li>\n<li><p>修饰变量：基本数据类型变量、引用类型变量。<strong>基本数据类型数值一旦被初始就不能被修改了，引用类型在对其初始化之后便不能指向另外一个<em>对象</em></strong>，<em>（注意）引用类型的值是可修改的</em></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">cn<span class=\"token punctuation\">.</span>hyqup<span class=\"token punctuation\">.</span>concurrency<span class=\"token punctuation\">.</span>immutable</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">HashMap</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Map</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * Copyright © 2021灼华. All rights reserved.\n *\n * @author create by hyq\n * @version 1.0\n * @date 2021/5/15\n * @description:\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ImmutableExample1</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Integer</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">String</span> b <span class=\"token operator\">=</span> <span class=\"token string\">\"2\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span>\n        c<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        c<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token comment\">//        a=11; 不可以修改，编译时候就不允许</span>\n<span class=\"token comment\">//        b=\"22\"; 不可以修改，编译时候就不允许</span>\n<span class=\"token comment\">//        c=new HashMap&lt;>(); 不可以指向新的对象，编译时候就不允许</span>\n        c<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 引用类型但是可以修改值</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"不可变引用数据类型\"><a href=\"#不可变引用数据类型\" class=\"headerlink\" title=\"不可变引用数据类型\"></a>不可变引用数据类型</h3><ul>\n<li><p>java提供：Collections.unmodifiableXXX:Collection、List、Set、Map…</p>\n</li>\n<li><p>guava提供:ImmutableXXX：Collection、List、Set、Map…</p>\n</li>\n</ul>\n<h2 id=\"线程封闭\"><a href=\"#线程封闭\" class=\"headerlink\" title=\"线程封闭\"></a>线程封闭</h2><p>当访问共享的可变数据时，通常需要同步。一种避免同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步，这种技术称为线程封闭（thread  confinement）,ThreadLocal</p>\n<h2 id=\"线程不安全的类与写法\"><a href=\"#线程不安全的类与写法\" class=\"headerlink\" title=\"线程不安全的类与写法\"></a>线程不安全的类与写法</h2><ul>\n<li><p>StringBuilder和StringBuffer两种字符串拼接类</p>\n<ul>\n<li>StringBuilder 线程不安全，但效率高</li>\n<li>StringBuffer 线程安全，但效率低</li>\n</ul>\n</li>\n<li><p>SimpleDateFormate</p>\n<p>多线程下不安全，可以采用jodaTime来实现</p>\n</li>\n<li><p>ArrayList,HashSet，HashMap等集合（使用同步容器解决）</p>\n<ul>\n<li>ArrayList</li>\n<li>HashSet</li>\n<li>HashMap</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"同步容器\"><a href=\"#同步容器\" class=\"headerlink\" title=\"同步容器\"></a>同步容器</h2><p>使用synchronized来实现</p>\n<ul>\n<li><p>ArrayList-&gt;Vector,Stack</p>\n</li>\n<li><p>HashMap-&gt;HashTable(key、value不能为null)</p>\n</li>\n<li><p>Collections.synchronizedXXX(List、Set、Map)</p>\n</li>\n</ul>\n<h2 id=\"并发容器及安全共享策略\"><a href=\"#并发容器及安全共享策略\" class=\"headerlink\" title=\"并发容器及安全共享策略\"></a>并发容器及安全共享策略</h2><p>同步容器的安全性得以保证，但是性能不是很好，所以Java中通常使用并发容器来替代同步容器，来完成并发下的工作</p>\n<h3 id=\"并发容器J-U-C-java-util-concurrent\"><a href=\"#并发容器J-U-C-java-util-concurrent\" class=\"headerlink\" title=\"并发容器J.U.C(java.util.concurrent)\"></a>并发容器J.U.C(java.util.concurrent)</h3><h4 id=\"ArrayList-–-CopyOnWriteArrayList\"><a href=\"#ArrayList-–-CopyOnWriteArrayList\" class=\"headerlink\" title=\"ArrayList –&gt; CopyOnWriteArrayList\"></a>ArrayList –&gt; CopyOnWriteArrayList</h4><h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念 :\"></a>概念 :</h5><p>简单的讲就是写操作时赋值,当有新元素添加到CopyOnWriteArrayList时,它先从原有的数组里边Copy一份出来然后在新的数组上做些操作,操作完成以后在将引用指向新的数组;CopyOnWriteArrayList所有的操作都是在锁的保护下进行的,这样做的目的主要是为了在多线程并发做add操作的时候复制出多个副本出来导致数据混乱</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点 :\"></a>缺点 :</h5><ul>\n<li><p>由于是copy的操作所以比较消耗内存,如果元素的内容较多的时候可能会触发GC</p>\n</li>\n<li><p>不能用于实时读的场景,它比较适合读多写少的场景(因为写的时候会复制新集合)</p>\n</li>\n</ul>\n<h5 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想 :\"></a>思想 :</h5><ul>\n<li>读写分离</li>\n<li>最终一致性</li>\n<li>另外开辟空间解决并发冲突</li>\n</ul>\n<h4 id=\"HashSet-–-CopyOnWriteArraySet和TreeSet-–-ConcurrentSkipListSet\"><a href=\"#HashSet-–-CopyOnWriteArraySet和TreeSet-–-ConcurrentSkipListSet\" class=\"headerlink\" title=\"HashSet –&gt; CopyOnWriteArraySet和TreeSet –&gt; ConcurrentSkipListSet\"></a>HashSet –&gt; CopyOnWriteArraySet和TreeSet –&gt; ConcurrentSkipListSet</h4><ul>\n<li>CopyOnWriteArraySet 线程安全，底层实现是使用CopyOnWriteArrayList，特性类似CopyOnWriteArrayList，适合于<strong>数据量小</strong>的时候，只读操作大于可变操作的时候</li>\n<li>ConcurrentSkipListSet 是jdk6新增的类，和TreeSet 一样支持自然排序，并且在构造的时候自己定义比较器。基于Map集合的，在多线程环境下，（set 、add、remove）等方法都是线程安全的，但是对于批量操作（addAll、removeAll等）并不能保证以原子方式进行操作，原因是底层还是（add、remove 等）批量操作的时候只能保证每一次的操作是原子性的，不能保证每一次操作不能被其他操作打断。所以<strong>使用批量操作的时候可能需要手动处理一下（加锁）</strong></li>\n</ul>\n<h4 id=\"HashMap-–-ConcurrentHashMap-和-TreeMap-–-ConcurrentSkipListMap\"><a href=\"#HashMap-–-ConcurrentHashMap-和-TreeMap-–-ConcurrentSkipListMap\" class=\"headerlink\" title=\"HashMap –&gt; ConcurrentHashMap 和 TreeMap –&gt; ConcurrentSkipListMap\"></a>HashMap –&gt; ConcurrentHashMap 和 TreeMap –&gt; ConcurrentSkipListMap</h4><ul>\n<li><p>ConcurrentHashMap  不允许空值，ConcurrentHashMap针对读操作多了特别多的优化,具有特别高的并发性</p>\n</li>\n<li><p>ConcurrentSkipListMap 底层是使用SkipList这种跳表的结构实现的</p>\n<p>对比：ConcurrentHashMap  存取效率高于ConcurrentSkipListMap 。但是：</p>\n<p>1、ConcurrentSkipListMap 的key是有序的 2、支持更高的并发</p>\n</li>\n</ul>\n<p>总结：这里只涉及到了一小部分J.U.C的知识点</p>","categories":[{"name":"Java","path":"api/categories/Java.json"},{"name":"Java进阶-并发","path":"api/categories/Java进阶-并发.json"}],"tags":[{"name":"不可变对象","path":"api/tags/不可变对象.json"},{"name":"集合","path":"api/tags/集合.json"}]}