{"title":"JUC(四)-Java内存模型之JMM","slug":"JUC-四-Java内存模型之JMM","date":"2022-06-18T11:20:46.000Z","updated":"2024-04-22T07:21:14.875Z","comments":true,"path":"api/articles/JUC-四-Java内存模型之JMM.json","excerpt":"Java内存模型下对变量的规则，多线程下变量赃读取脏写的原因，内存屏障及其原理分析，以及Volatile的关键字的作用，原理。使用场景","covers":null,"content":"<p>Java内存模型下对变量的规则，多线程下变量赃读取脏写的原因，内存屏障及其原理分析，以及Volatile的关键字的作用，原理。使用场景</p>\n<span id=\"more\"></span>\n\n<p>Java并发多线程与高并发(二)-并发基础 已经对概念进行的基础的覆盖，接下来逐步加深</p>\n<h2 id=\"多线程先行发生原则之happens-before\"><a href=\"#多线程先行发生原则之happens-before\" class=\"headerlink\" title=\"多线程先行发生原则之happens-before\"></a>多线程先行发生原则之happens-before</h2><h3 id=\"happens-before之8条\"><a href=\"#happens-before之8条\" class=\"headerlink\" title=\"happens-before之8条\"></a>happens-before之8条</h3><ul>\n<li><strong>程序次序规则</strong>（Program Order Rule）：写在前面的操作先行发生于写在后面的操作</li>\n<li><strong>管程锁定规则</strong>（Monitor Lock Rule）：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</li>\n<li><strong>volatile 变量规则</strong>（Volatile Variable Rule）：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，<strong>前面的写对后面的读是可见的</strong>。这里的 “后面” 同样是指时间上的先后。</li>\n<li><strong>传递性</strong>（Transitivity）：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。</li>\n<li><strong>线程启动规则</strong>（Thread Start Rule）：Thread 对象的 start() 方法先行发生于此线程的每一个动作。</li>\n<li><strong>线程中断规则</strong>（Thread Interruption Rule）：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread 对象的 interrupted() 方法检测到是否有中断发生。</li>\n<li><strong>线程终止规则</strong>（Thread Termination Rule）：<strong>线程中的所有操作都先行发生于对此线程的终止检测。</strong>我们可以通过 Thread 对象的 join() 方法是否结束、Thread 对象的 isAlive() 的返回值等手段检测线程是否已经终止执行。</li>\n<li><strong>对象终结规则</strong>（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</li>\n</ul>\n<h2 id=\"Volatile内存屏障（难点）\"><a href=\"#Volatile内存屏障（难点）\" class=\"headerlink\" title=\"Volatile内存屏障（难点）\"></a>Volatile内存屏障（难点）</h2><blockquote>\n<p>并发编程的三大问题：原子性 可见性  有序性</p>\n<p>volatile 保证了可见性和有序性</p>\n</blockquote>\n<p>volatile：</p>\n<p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值<code>立即刷新回主存</code>中</p>\n<p>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主存中读取共享变量 </p>\n<p>所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取</p>\n<h3 id=\"内存屏障-保证了可见性\"><a href=\"#内存屏障-保证了可见性\" class=\"headerlink\" title=\"内存屏障(保证了可见性)\"></a>内存屏障(保证了可见性)</h3><p>内存屏障指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令</p>\n<p>对一个volatie域的写，happens-before与任意后续对这个volatile域的读，也叫写后读</p>\n<p> 底层是C++</p>\n<p>loadload  storestore  loadstore  storeload 四个内存屏障策略</p>\n<table>\n<thead>\n<tr>\n<th>屏障类型</th>\n<th>指令示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>loadload</td>\n<td>load1;loadload;load2</td>\n<td>保证load1读取操作在load2读取操作之前执行</td>\n</tr>\n<tr>\n<td>storestore</td>\n<td>store1;storestore;store2</td>\n<td>在store2及其后的写操作执行前，保证store1的写操作已经刷新到主内存</td>\n</tr>\n<tr>\n<td>loadstore</td>\n<td>load1;storestore;store2</td>\n<td>在store2及其后的写操作执行前，保证load1的读操作已读取结束</td>\n</tr>\n<tr>\n<td>storeload</td>\n<td>store1;storestore;load2</td>\n<td>保证store1的写操作已刷新到主内存之后，load之后的读操作才能执行</td>\n</tr>\n</tbody></table>\n<p>总结：（重点）</p>\n<p>1、当第一个操作Volatile读时候，无论第二个操作是什么，都不能重排序，保证Volatile读之后的操作不会重排序到Volatile读之前</p>\n<p>2、当第二个操作是Volatile写时候，无论第一个操作是什么，都不能重排序，保证Volatile写之前的操作不会被重排序到Volatile写之后</p>\n<p>3、当第一个操作是Volatile写时，第二个操作是Volatile读时，不能重排</p>\n<p>延伸：使用两个Volatile时候，只有第一个是Volatile读，第二个也是Volatile读才可以重排，其他所有情况均不可以重排</p>\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><p>写总结：</p>\n<p>1、在每个volatile写操作的前面插入一个storestore屏障</p>\n<p>2、在每个volatile写操作的后面插入一个storeload屏障</p>\n<p>读总结</p>\n<p>1、在每个volatile读操作后面插入一个loadload屏障</p>\n<p>2、在每个volatile读操作后面插入一个loadstore屏障</p>\n<h2 id=\"Volatile变量的读写过程\"><a href=\"#Volatile变量的读写过程\" class=\"headerlink\" title=\"Volatile变量的读写过程\"></a>Volatile变量的读写过程</h2><blockquote>\n<p><strong>read(读取)→load(加载)→use(使用)→assign(赋值)→store(存储)→write(写入)→lock(锁定)→unlock(解锁)</strong></p>\n</blockquote>\n<p>read： 作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存。</p>\n<p>laod：作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载。</p>\n<p>use：作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作。</p>\n<p>assign：作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作。</p>\n<p>write：作用于主内存，将store传输过来的变量值赋值给主内存中的变量。</p>\n<p>由于上述操作，只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁，所以JVM另外提供了两个原子指令：</p>\n<p>lock：作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。</p>\n<p>unlock：作用于主内存，将一个处于锁定状态的变量释放，然后才能被其它线程占用。</p>\n<h2 id=\"Volatile-为什么没有原子性？\"><a href=\"#Volatile-为什么没有原子性？\" class=\"headerlink\" title=\"Volatile 为什么没有原子性？\"></a>Volatile 为什么没有原子性？</h2><p>复合性的操作不具有原子性</p>\n<p>example:i++</p>\n<p>i++ 被拆分处理三个指令：</p>\n<p>1、getfield拿到原始i</p>\n<p>2、执行iadd进行加一操作</p>\n<p>3、执行putfield把累加后的值写回</p>\n<p>如果第二个线程在第一个线程读取旧值和写回新值期间读取了i的值，那么第二个线程就会和第一个线程看到同一个值，并执行加一操作，导致线程安全失败。</p>\n<h3 id=\"本质原因\"><a href=\"#本质原因\" class=\"headerlink\" title=\"本质原因\"></a>本质原因</h3><p>内存屏障保证了read(读取)→load(加载)→use(使用)  以及assign(赋值)→store(存储)→write(写入)成为了两个不可分割的原子操作，但是在use和assign之间依然有真空期，这个时候如i++ 这样多个操作就会导致多线程安全问题</p>\n<h2 id=\"Volatile的应用场景\"><a href=\"#Volatile的应用场景\" class=\"headerlink\" title=\"Volatile的应用场景\"></a>Volatile的应用场景</h2><blockquote>\n<p>通常用作保存某个boolean 或者 int 值</p>\n</blockquote>\n","more":"<p>Java并发多线程与高并发(二)-并发基础 已经对概念进行的基础的覆盖，接下来逐步加深</p>\n<h2 id=\"多线程先行发生原则之happens-before\"><a href=\"#多线程先行发生原则之happens-before\" class=\"headerlink\" title=\"多线程先行发生原则之happens-before\"></a>多线程先行发生原则之happens-before</h2><h3 id=\"happens-before之8条\"><a href=\"#happens-before之8条\" class=\"headerlink\" title=\"happens-before之8条\"></a>happens-before之8条</h3><ul>\n<li><strong>程序次序规则</strong>（Program Order Rule）：写在前面的操作先行发生于写在后面的操作</li>\n<li><strong>管程锁定规则</strong>（Monitor Lock Rule）：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</li>\n<li><strong>volatile 变量规则</strong>（Volatile Variable Rule）：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，<strong>前面的写对后面的读是可见的</strong>。这里的 “后面” 同样是指时间上的先后。</li>\n<li><strong>传递性</strong>（Transitivity）：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。</li>\n<li><strong>线程启动规则</strong>（Thread Start Rule）：Thread 对象的 start() 方法先行发生于此线程的每一个动作。</li>\n<li><strong>线程中断规则</strong>（Thread Interruption Rule）：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread 对象的 interrupted() 方法检测到是否有中断发生。</li>\n<li><strong>线程终止规则</strong>（Thread Termination Rule）：<strong>线程中的所有操作都先行发生于对此线程的终止检测。</strong>我们可以通过 Thread 对象的 join() 方法是否结束、Thread 对象的 isAlive() 的返回值等手段检测线程是否已经终止执行。</li>\n<li><strong>对象终结规则</strong>（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</li>\n</ul>\n<h2 id=\"Volatile内存屏障（难点）\"><a href=\"#Volatile内存屏障（难点）\" class=\"headerlink\" title=\"Volatile内存屏障（难点）\"></a>Volatile内存屏障（难点）</h2><blockquote>\n<p>并发编程的三大问题：原子性 可见性  有序性</p>\n<p>volatile 保证了可见性和有序性</p>\n</blockquote>\n<p>volatile：</p>\n<p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值<code>立即刷新回主存</code>中</p>\n<p>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主存中读取共享变量 </p>\n<p>所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取</p>\n<h3 id=\"内存屏障-保证了可见性\"><a href=\"#内存屏障-保证了可见性\" class=\"headerlink\" title=\"内存屏障(保证了可见性)\"></a>内存屏障(保证了可见性)</h3><p>内存屏障指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令</p>\n<p>对一个volatie域的写，happens-before与任意后续对这个volatile域的读，也叫写后读</p>\n<p> 底层是C++</p>\n<p>loadload  storestore  loadstore  storeload 四个内存屏障策略</p>\n<table>\n<thead>\n<tr>\n<th>屏障类型</th>\n<th>指令示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>loadload</td>\n<td>load1;loadload;load2</td>\n<td>保证load1读取操作在load2读取操作之前执行</td>\n</tr>\n<tr>\n<td>storestore</td>\n<td>store1;storestore;store2</td>\n<td>在store2及其后的写操作执行前，保证store1的写操作已经刷新到主内存</td>\n</tr>\n<tr>\n<td>loadstore</td>\n<td>load1;storestore;store2</td>\n<td>在store2及其后的写操作执行前，保证load1的读操作已读取结束</td>\n</tr>\n<tr>\n<td>storeload</td>\n<td>store1;storestore;load2</td>\n<td>保证store1的写操作已刷新到主内存之后，load之后的读操作才能执行</td>\n</tr>\n</tbody></table>\n<p>总结：（重点）</p>\n<p>1、当第一个操作Volatile读时候，无论第二个操作是什么，都不能重排序，保证Volatile读之后的操作不会重排序到Volatile读之前</p>\n<p>2、当第二个操作是Volatile写时候，无论第一个操作是什么，都不能重排序，保证Volatile写之前的操作不会被重排序到Volatile写之后</p>\n<p>3、当第一个操作是Volatile写时，第二个操作是Volatile读时，不能重排</p>\n<p>延伸：使用两个Volatile时候，只有第一个是Volatile读，第二个也是Volatile读才可以重排，其他所有情况均不可以重排</p>\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><p>写总结：</p>\n<p>1、在每个volatile写操作的前面插入一个storestore屏障</p>\n<p>2、在每个volatile写操作的后面插入一个storeload屏障</p>\n<p>读总结</p>\n<p>1、在每个volatile读操作后面插入一个loadload屏障</p>\n<p>2、在每个volatile读操作后面插入一个loadstore屏障</p>\n<h2 id=\"Volatile变量的读写过程\"><a href=\"#Volatile变量的读写过程\" class=\"headerlink\" title=\"Volatile变量的读写过程\"></a>Volatile变量的读写过程</h2><blockquote>\n<p><strong>read(读取)→load(加载)→use(使用)→assign(赋值)→store(存储)→write(写入)→lock(锁定)→unlock(解锁)</strong></p>\n</blockquote>\n<p>read： 作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存。</p>\n<p>laod：作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载。</p>\n<p>use：作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作。</p>\n<p>assign：作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作。</p>\n<p>write：作用于主内存，将store传输过来的变量值赋值给主内存中的变量。</p>\n<p>由于上述操作，只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁，所以JVM另外提供了两个原子指令：</p>\n<p>lock：作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。</p>\n<p>unlock：作用于主内存，将一个处于锁定状态的变量释放，然后才能被其它线程占用。</p>\n<h2 id=\"Volatile-为什么没有原子性？\"><a href=\"#Volatile-为什么没有原子性？\" class=\"headerlink\" title=\"Volatile 为什么没有原子性？\"></a>Volatile 为什么没有原子性？</h2><p>复合性的操作不具有原子性</p>\n<p>example:i++</p>\n<p>i++ 被拆分处理三个指令：</p>\n<p>1、getfield拿到原始i</p>\n<p>2、执行iadd进行加一操作</p>\n<p>3、执行putfield把累加后的值写回</p>\n<p>如果第二个线程在第一个线程读取旧值和写回新值期间读取了i的值，那么第二个线程就会和第一个线程看到同一个值，并执行加一操作，导致线程安全失败。</p>\n<h3 id=\"本质原因\"><a href=\"#本质原因\" class=\"headerlink\" title=\"本质原因\"></a>本质原因</h3><p>内存屏障保证了read(读取)→load(加载)→use(使用)  以及assign(赋值)→store(存储)→write(写入)成为了两个不可分割的原子操作，但是在use和assign之间依然有真空期，这个时候如i++ 这样多个操作就会导致多线程安全问题</p>\n<h2 id=\"Volatile的应用场景\"><a href=\"#Volatile的应用场景\" class=\"headerlink\" title=\"Volatile的应用场景\"></a>Volatile的应用场景</h2><blockquote>\n<p>通常用作保存某个boolean 或者 int 值</p>\n</blockquote>","categories":[{"name":"Java","path":"api/categories/Java.json"},{"name":"JUC","path":"api/categories/JUC.json"}],"tags":[]}