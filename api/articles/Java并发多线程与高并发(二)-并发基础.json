{"title":"Java并发多线程与高并发(二)-并发基础","slug":"Java并发多线程与高并发(二)-并发基础","date":"2021-04-28T15:33:36.000Z","updated":"2024-04-22T07:21:14.887Z","comments":true,"path":"api/articles/Java并发多线程与高并发(二)-并发基础.json","excerpt":"在多线程的情况下，从java内存模型和CPU乱序优化浅谈多线程不安全产生的原因","covers":["http://hyqup-blog-upyun.test.upcdn.net/img/java-memory-model-2-1620570065967.png","http://hyqup-blog-upyun.test.upcdn.net/img/6.jpg","http://hyqup-blog-upyun.test.upcdn.net/img/8.jpg"],"content":"<p>在多线程的情况下，从java内存模型和CPU乱序优化浅谈多线程不安全产生的原因</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>序章中我们看到多线程中看到基数Demo计数出现误差，本章节从计算机原理和Java虚拟机相关探讨为什么会产生这些异常</p>\n</blockquote>\n<h2 id=\"CPU多级缓存\"><a href=\"#CPU多级缓存\" class=\"headerlink\" title=\"CPU多级缓存\"></a>CPU多级缓存</h2><p>cpu执行频率太快，快到主存跟不上，这样在处理器处理过程中，CPU常常需要等待主存，浪费资源。所以多级缓存（cache）的出现，就是<strong>为了解决CPU和内存之间速度不匹配的问题</strong>（cpu-&gt;cache-&gt;memory）</p>\n<h3 id=\"CPU-缓存的意义\"><a href=\"#CPU-缓存的意义\" class=\"headerlink\" title=\"CPU 缓存的意义\"></a>CPU 缓存的意义</h3><ul>\n<li><strong>时间局部性（Temporal Locality）</strong>：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</li>\n<li><strong>空间局部性（Spatial Locality）</strong>：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</li>\n</ul>\n<h3 id=\"CPU缓存一致性协议-MESI\"><a href=\"#CPU缓存一致性协议-MESI\" class=\"headerlink\" title=\"CPU缓存一致性协议(MESI)\"></a>CPU缓存一致性协议(MESI)</h3><p>M 修改 (Modified)  E 独享、互斥 (Exclusive) S 共享 (Shared) I 无效 (Invalid)</p>\n<p>该协议目的是<strong>为了保证CPU cache之间的共享数据的一致性</strong></p>\n<p>更多详细信息请查阅资料</p>\n<h3 id=\"CPU多级缓存-乱序执行优化\"><a href=\"#CPU多级缓存-乱序执行优化\" class=\"headerlink\" title=\"CPU多级缓存-乱序执行优化\"></a>CPU多级缓存-乱序执行优化</h3><p><strong>处理器为提高运算速度而做出违背代码原有顺序的优化</strong></p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//①</span>\n<span class=\"token keyword\">int</span> b<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//②</span>\n<span class=\"token keyword\">int</span> c<span class=\"token operator\">=</span>a<span class=\"token operator\">+</span>b<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//③</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<p>cpu乱序执行的时候 可能顺序变为②-&gt;①-&gt;③</p>\n<p>在单线程单核的情况下不会出现问题，复杂的顺序的时候<strong>多线程下可能会存在问题</strong></p>\n<h2 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h2><p>了解Java内存模型，了解Java内存模型如何对上述进行优化的</p>\n<p>Java内存模型-JMM(Java Memory Model) Java内存模式是一种虚拟机规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p>\n<p><img src=\"http://hyqup-blog-upyun.test.upcdn.net/img/java-memory-model-2-1620570065967.png\" alt=\"java-memory-model-2\"></p>\n<p>cpu缓存模型结构图</p>\n<p><img src=\"http://hyqup-blog-upyun.test.upcdn.net/img/6.jpg\" alt=\"6\"></p>\n<p>Java内存模型抽象结构图</p>\n<p><img src=\"http://hyqup-blog-upyun.test.upcdn.net/img/8.jpg\" alt=\"8\"></p>\n<p>由此可见，Java 内存模型(JMM)同 CPU 缓存模型结构类似，是基于 CPU 缓存模型来建立的。</p>\n<h3 id=\"主内存、工作内存的定义\"><a href=\"#主内存、工作内存的定义\" class=\"headerlink\" title=\"主内存、工作内存的定义\"></a>主内存、工作内存的定义</h3><ul>\n<li><strong>主内存</strong></li>\n</ul>\n<blockquote>\n<p>主内存主要存储的是 Java 实例对象，即所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。</p>\n</blockquote>\n<ul>\n<li><strong>工作内存（本地内存）</strong></li>\n</ul>\n<blockquote>\n<p>工作内存主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，即每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关 Native 方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。</p>\n</blockquote>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\"><span class=\"token title important\"><span class=\"token punctuation\">##</span> 参考</span>\n<span class=\"token url-reference url\"><span class=\"token punctuation\">[</span><span class=\"token variable\">^1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> http://ifeve.com/java-memory-model-6/</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></div></figure>\n\n","more":"<blockquote>\n<p>序章中我们看到多线程中看到基数Demo计数出现误差，本章节从计算机原理和Java虚拟机相关探讨为什么会产生这些异常</p>\n</blockquote>\n<h2 id=\"CPU多级缓存\"><a href=\"#CPU多级缓存\" class=\"headerlink\" title=\"CPU多级缓存\"></a>CPU多级缓存</h2><p>cpu执行频率太快，快到主存跟不上，这样在处理器处理过程中，CPU常常需要等待主存，浪费资源。所以多级缓存（cache）的出现，就是<strong>为了解决CPU和内存之间速度不匹配的问题</strong>（cpu-&gt;cache-&gt;memory）</p>\n<h3 id=\"CPU-缓存的意义\"><a href=\"#CPU-缓存的意义\" class=\"headerlink\" title=\"CPU 缓存的意义\"></a>CPU 缓存的意义</h3><ul>\n<li><strong>时间局部性（Temporal Locality）</strong>：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</li>\n<li><strong>空间局部性（Spatial Locality）</strong>：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</li>\n</ul>\n<h3 id=\"CPU缓存一致性协议-MESI\"><a href=\"#CPU缓存一致性协议-MESI\" class=\"headerlink\" title=\"CPU缓存一致性协议(MESI)\"></a>CPU缓存一致性协议(MESI)</h3><p>M 修改 (Modified)  E 独享、互斥 (Exclusive) S 共享 (Shared) I 无效 (Invalid)</p>\n<p>该协议目的是<strong>为了保证CPU cache之间的共享数据的一致性</strong></p>\n<p>更多详细信息请查阅资料</p>\n<h3 id=\"CPU多级缓存-乱序执行优化\"><a href=\"#CPU多级缓存-乱序执行优化\" class=\"headerlink\" title=\"CPU多级缓存-乱序执行优化\"></a>CPU多级缓存-乱序执行优化</h3><p><strong>处理器为提高运算速度而做出违背代码原有顺序的优化</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//①</span>\n<span class=\"token keyword\">int</span> b<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//②</span>\n<span class=\"token keyword\">int</span> c<span class=\"token operator\">=</span>a<span class=\"token operator\">+</span>b<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//③</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>cpu乱序执行的时候 可能顺序变为②-&gt;①-&gt;③</p>\n<p>在单线程单核的情况下不会出现问题，复杂的顺序的时候<strong>多线程下可能会存在问题</strong></p>\n<h2 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h2><p>了解Java内存模型，了解Java内存模型如何对上述进行优化的</p>\n<p>Java内存模型-JMM(Java Memory Model) Java内存模式是一种虚拟机规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p>\n<p><img src=\"http://hyqup-blog-upyun.test.upcdn.net/img/java-memory-model-2-1620570065967.png\" alt=\"java-memory-model-2\"></p>\n<p>cpu缓存模型结构图</p>\n<p><img src=\"http://hyqup-blog-upyun.test.upcdn.net/img/6.jpg\" alt=\"6\"></p>\n<p>Java内存模型抽象结构图</p>\n<p><img src=\"http://hyqup-blog-upyun.test.upcdn.net/img/8.jpg\" alt=\"8\"></p>\n<p>由此可见，Java 内存模型(JMM)同 CPU 缓存模型结构类似，是基于 CPU 缓存模型来建立的。</p>\n<h3 id=\"主内存、工作内存的定义\"><a href=\"#主内存、工作内存的定义\" class=\"headerlink\" title=\"主内存、工作内存的定义\"></a>主内存、工作内存的定义</h3><ul>\n<li><strong>主内存</strong></li>\n</ul>\n<blockquote>\n<p>主内存主要存储的是 Java 实例对象，即所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。</p>\n</blockquote>\n<ul>\n<li><strong>工作内存（本地内存）</strong></li>\n</ul>\n<blockquote>\n<p>工作内存主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，即每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关 Native 方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。</p>\n</blockquote>\n<pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\"><span class=\"token title important\"><span class=\"token punctuation\">##</span> 参考</span>\n<span class=\"token url-reference url\"><span class=\"token punctuation\">[</span><span class=\"token variable\">^1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> http://ifeve.com/java-memory-model-6/</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>","categories":[{"name":"Java","path":"api/categories/Java.json"},{"name":"Java进阶-并发","path":"api/categories/Java进阶-并发.json"}],"tags":[{"name":"CPU多级缓存","path":"api/tags/CPU多级缓存.json"},{"name":"java内存模型","path":"api/tags/java内存模型.json"}]}