{"title":"JVM与GC调优(二)-类加载子系统篇","slug":"JVM与GC调优-二-类加载子系统篇","date":"2022-09-21T12:53:12.000Z","updated":"2024-04-22T07:21:14.883Z","comments":true,"path":"api/articles/JVM与GC调优-二-类加载子系统篇.json","excerpt":"类的加载过程解析与双亲委派机制与破坏双亲委派机制相关","covers":["http://hyqup-blog-upyun.test.upcdn.net/img/image-20220921210744405.png","http://file.hyqup.cn/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%A7%8D%E7%B1%BB.png","http://hyqup-blog-upyun.test.upcdn.net/img/20210601230727770.png"],"content":"<p>类的加载过程解析与双亲委派机制与破坏双亲委派机制相关</p>\n<span id=\"more\"></span>\n\n<h2 id=\"类加载作用\"><a href=\"#类加载作用\" class=\"headerlink\" title=\"类加载作用\"></a>类加载作用</h2><p><strong>ClassLoader</strong></p>\n<p><code>ClassLoader</code>是Java的核心组件，所有的Class都是由ClassLoader进行加载的</p>\n<p><code>ClassLoader</code>负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例，然后交给Java虚拟机进行链接、初始化等操作</p>\n<p><code>ClassLoader</code>在整个装载阶段，只能影响到类的<code>加载</code>（<code>Loading阶段</code>），而无法通过ClassLoader去改变类的<code>链接和初始化</code>行为。至于它是否可以运行，则由Execution Engine决定。</p>\n<h2 id=\"类加载的时机\"><a href=\"#类加载的时机\" class=\"headerlink\" title=\"类加载的时机\"></a>类加载的时机</h2><ul>\n<li>遇到 <code>new</code> 、 <code>getstatic</code> 、 <code>putstatic</code> 和 <code>invokestatic</code> 这四条指令时，如果对应的类没有初始化，则要对对应的类先进行初始化</li>\n<li>使用 java.lang.reflect 包方法时，对类进行<strong>反射调用</strong>的时候</li>\n<li>初始化一个类的时候发现其<strong>父类</strong>还没初始化，要先初始化其<strong>父类</strong></li>\n<li>当虚拟机开始启动时，用户需要指定一个主类（main），虚拟机会先执行这个主类的初始化。</li>\n</ul>\n<h2 id=\"类加载的顺序\"><a href=\"#类加载的顺序\" class=\"headerlink\" title=\"类加载的顺序\"></a>类加载的顺序</h2><p><strong>检查顺序是自底向上</strong>：加载过程中会先检查类是否被已加载，从Custom ClassLoader到BootStrap</p>\n<p>ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有</p>\n<p>ClassLoader加载一次。</p>\n<p><strong>加载的顺序是自顶向下</strong>：也就是由上层来逐层尝试加载此类。</p>\n<h2 id=\"类的加载过程\"><a href=\"#类的加载过程\" class=\"headerlink\" title=\"类的加载过程\"></a>类的加载过程</h2><blockquote>\n<p>类加载主要过程分为 加载、链接、初始化三个阶段，而链接阶段又分为验证 准备 解析</p>\n</blockquote>\n<p><img src=\"http://hyqup-blog-upyun.test.upcdn.net/img/image-20220921210744405.png\" alt=\"image-20220921210744405\"></p>\n<p> ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p>\n<p> <a href=\"https://www.cnblogs.com/aaabbbcccddd/p/14539063.html\">JVM内存模型——堆(heap)、栈(stack)和方法区(method)</a></p>\n<h3 id=\"过程一：Loading（加载）阶段\"><a href=\"#过程一：Loading（加载）阶段\" class=\"headerlink\" title=\"过程一：Loading（加载）阶段\"></a>过程一：Loading（加载）阶段</h3><blockquote>\n<p>将Java类的字节码文件加载到机器内存中，并在内存中构建出java类的原型实例（类模板对象），类结构信息存储到<code>方法区</code></p>\n</blockquote>\n<p><code>类模板对象</code>：本质就是java类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，在JVM运行的时候，就可以通过类模板获取Java类的所有信息，能够对Java类的成员变量进行遍历，也能进行Java 方法的调用</p>\n<p>反射的原理也就JVM在运行期间去拿到类模板信息</p>\n<h3 id=\"过程二：Linking（链接）阶段\"><a href=\"#过程二：Linking（链接）阶段\" class=\"headerlink\" title=\"过程二：Linking（链接）阶段\"></a>过程二：Linking（链接）阶段</h3><h4 id=\"小节一：链接阶段值Verification-验证\"><a href=\"#小节一：链接阶段值Verification-验证\" class=\"headerlink\" title=\"小节一：链接阶段值Verification(验证)\"></a>小节一：链接阶段值Verification(验证)</h4><blockquote>\n<p>目的是<strong>保证加载的字节码是合法、合理并符合规范的</strong></p>\n</blockquote>\n<p>验证的内容则涵盖了类数据信息的<strong>格式验证、语义检查、字节码验证，以及符号引用验证</strong>等</p>\n<h4 id=\"小节二：链接阶段值Preparation-准备\"><a href=\"#小节二：链接阶段值Preparation-准备\" class=\"headerlink\" title=\"小节二：链接阶段值Preparation(准备)\"></a>小节二：链接阶段值Preparation(准备)</h4><blockquote>\n<p><strong>为类的静态变量分配内存，并将其初始化为默认值</strong></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>默认初始值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>byte</td>\n<td>(byte)0</td>\n</tr>\n<tr>\n<td>short</td>\n<td>(short)0</td>\n</tr>\n<tr>\n<td>int</td>\n<td>0</td>\n</tr>\n<tr>\n<td>long</td>\n<td>OL</td>\n</tr>\n<tr>\n<td>float</td>\n<td>0.0f</td>\n</tr>\n<tr>\n<td>double</td>\n<td>0.0</td>\n</tr>\n<tr>\n<td>char</td>\n<td>\\u0000</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>false</td>\n</tr>\n<tr>\n<td>reference</td>\n<td>null</td>\n</tr>\n</tbody></table>\n<h4 id=\"小节三：链接阶段值Resolution-解析\"><a href=\"#小节三：链接阶段值Resolution-解析\" class=\"headerlink\" title=\"小节三：链接阶段值Resolution(解析)\"></a>小节三：链接阶段值Resolution(解析)</h4><blockquote>\n<p><strong>解析阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。</strong></p>\n</blockquote>\n<p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是<strong>在Class类文件中，通过常量池进行了大量的符号引用</strong>。但是在程序实际运行时，只有符号引用是不够的，比如当println()方法被调用时，系统需要明确知道该方法的位置。</p>\n<h3 id=\"过程三：Initialization（初始化）阶段\"><a href=\"#过程三：Initialization（初始化）阶段\" class=\"headerlink\" title=\"过程三：Initialization（初始化）阶段\"></a>过程三：Initialization（初始化）阶段</h3><blockquote>\n<p><em><strong>初始化阶段，简言之，为类的静态变量赋予正确的初始值。</strong></em></p>\n</blockquote>\n<p>1、具体描述</p>\n<p>类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行Java字节码。<strong>（即：到了初始化阶段，才真正开始执行类中定义的Java程序代码。）</strong></p>\n<p>初始化阶段的重要工作是执行类的初始化方法：<code>&lt;clinit&gt;()方法</code></p>\n<p>该方法仅能由<code>Java编译器生成</code>并由<code>JVM调用</code>，程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法，虽然该方法也是由字节码指令所组成。<br>它是由类静态成员的赋值语句以及static语句块合并产生的。 </p>\n<p>clinit编译生成：</p>\n<p>​\t<strong>静态的变量赋值编译才会生成clint方法</strong></p>\n<p>案例说明：</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//不会，不是静态，链接(Linking)的准备阶段赋值</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span> <span class=\"token comment\">//不会，没有赋值</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//final 修饰后不是变量是常量所以也不会</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span>  <span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 此时会，静态变量初始化赋值</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<h4 id=\"static-final-修饰的一定不会在初始化赋值吗？\"><a href=\"#static-final-修饰的一定不会在初始化赋值吗？\" class=\"headerlink\" title=\"static final 修饰的一定不会在初始化赋值吗？\"></a>static final 修饰的一定不会在初始化赋值吗？</h4><p>eg: public static final Integter INTEGTER_CONSTANT&#x3D;Integer.valueOf(1000);</p>\n<p>因为这里不是常量而是一个方法调用，所以此时也会生成clint</p>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>使用 static+final修饰的成员变量，称为：<code>全局常量</code></p>\n<p>什么时候在<code>链接</code>的准备阶段赋值：给该全局常量赋的值是<code>字面量</code>或者<code>常量</code>，不涉及到<code>方法的调用</code>，其余场景在初始化阶段赋值</p>\n<h3 id=\"类的初始化情况：主动使用-vs被动使用\"><a href=\"#类的初始化情况：主动使用-vs被动使用\" class=\"headerlink\" title=\"类的初始化情况：主动使用 vs被动使用\"></a>类的初始化情况：主动使用 vs被动使用</h3><blockquote>\n<p>Java程序对类的使用分为两种：<strong>主动使用和被动使用</strong>。</p>\n</blockquote>\n<h4 id=\"主动使用\"><a href=\"#主动使用\" class=\"headerlink\" title=\"主动使用\"></a>主动使用</h4><p>Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，<strong>一个类或接口在初次使用前，必须要进行初始化</strong>。这里指的“使用”，是指<code>主动使用</code>，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成）</p>\n<p>1.当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化；</p>\n<p>2.当调用类的静态方法时，即当使用了字节码invokestatic指令；</p>\n<p>3.当使用类、接口的静态字段时（final修饰特殊考虑），比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作）；</p>\n<p>4.当使用java.lang.reflect包中的方法反射类的方法时。比如:Class.forName；</p>\n<p>5.当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；</p>\n<p>6.如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化；</p>\n<p>7.当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类；</p>\n<p>8.当初次调用 MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）；</p>\n<h4 id=\"被动使用\"><a href=\"#被动使用\" class=\"headerlink\" title=\"被动使用\"></a>被动使用</h4><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。<strong>被动使用不会引起类的初始化。</strong></p>\n<ol>\n<li>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化；<br>当通过子类引用父类的静态变量，不会导致子类初始化；</li>\n<li>通过数组定义类引用，不会触发此类的初始化；</li>\n<li>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了；</li>\n<li>调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化；</li>\n</ol>\n<h2 id=\"类的加载器分类\"><a href=\"#类的加载器分类\" class=\"headerlink\" title=\"类的加载器分类\"></a>类的加载器分类</h2><h3 id=\"显示加载与隐士加载\"><a href=\"#显示加载与隐士加载\" class=\"headerlink\" title=\"显示加载与隐士加载\"></a>显示加载与隐士加载</h3><ul>\n<li><strong>显示加载</strong>：指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName（name）或this.getClass().getClassLoader().loadClass()加载class对象</li>\n<li><strong>隐式加载</strong>：不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li>\n</ul>\n<h3 id=\"类加载机制的基本特征\"><a href=\"#类加载机制的基本特征\" class=\"headerlink\" title=\"类加载机制的基本特征\"></a>类加载机制的基本特征</h3><ul>\n<li><strong>双亲委派模型</strong>：</li>\n<li><strong>可见性</strong>：子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。</li>\n<li><strong>单一性</strong>：父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</li>\n</ul>\n<h3 id=\"类加载器分类（两大类）\"><a href=\"#类加载器分类（两大类）\" class=\"headerlink\" title=\"类加载器分类（两大类）\"></a>类加载器分类（两大类）</h3><blockquote>\n<p><strong>引导类加载器(Bootstrap ClassLoader)<strong>和</strong>自定义类加载器(User-Defined ClassLoader)</strong></p>\n</blockquote>\n<p><img src=\"http://file.hyqup.cn/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%A7%8D%E7%B1%BB.png\" alt=\"类加载器种类\"></p>\n<blockquote>\n<p>父子加载类实际上不存在继承关系，而是一种组合关系</p>\n</blockquote>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassLoader</span> <span class=\"token punctuation\">&#123;</span>\n\n\t<span class=\"token class-name\">ClassLoader</span> parent<span class=\"token punctuation\">;</span>       父类加载器\n\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">ClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassLoader</span> parent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>parent <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ParentClassLoader</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ClassLoader</span> <span class=\"token punctuation\">&#123;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">ParentClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassLoader</span> parent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n\t<span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ChildClassLoader</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ClassLoader</span> <span class=\"token punctuation\">&#123;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">ChildClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassLoader</span> parent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n\t<span class=\"token comment\">//parent = new ParentClassLoader();</span>\n\n\t<span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<h3 id=\"ClassLoader加载逻辑\"><a href=\"#ClassLoader加载逻辑\" class=\"headerlink\" title=\"ClassLoader加载逻辑\"></a>ClassLoader加载逻辑</h3><figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> resolve<span class=\"token punctuation\">)</span>\n     <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ClassNotFoundException</span>\n <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token function\">getClassLoadingLock</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n         <span class=\"token comment\">// First, check if the class has already been loaded</span>\n         <span class=\"token comment\">// 查找一下这个类是不是已经加载过了</span>\n         <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> c <span class=\"token operator\">=</span> <span class=\"token function\">findLoadedClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token comment\">//如果没有加载过</span>\n         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n             <span class=\"token keyword\">long</span> t0 <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n             <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n                 <span class=\"token comment\">//parent  每个类加载器都有个父加载器,判断是否有父类加载器，存在则调用父类加载器去加载。双亲委派模型在这</span>\n                 <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                     c <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">.</span><span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n                     <span class=\"token comment\">//如果父类加载器为空，就说明到达顶层也就是BootstrapClassLoader,BootstrapClassLoader属于C/C++编写这里拿不到对象的</span>\n                     c <span class=\"token operator\">=</span> <span class=\"token function\">findBootstrapClassOrNull</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token punctuation\">&#125;</span>\n             <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassNotFoundException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                 <span class=\"token comment\">// ClassNotFoundException thrown if class not found</span>\n                 <span class=\"token comment\">// from the non-null parent class loader</span>\n             <span class=\"token punctuation\">&#125;</span>\n\t<span class=\"token comment\">//如果父类加载都没有加载，则使用当前类加载</span>\n             <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                 <span class=\"token comment\">// If still not found, then invoke findClass in order</span>\n                 <span class=\"token comment\">// to find the class.</span>\n                 <span class=\"token keyword\">long</span> t1 <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token comment\">// findClass用于加载</span>\n                 c <span class=\"token operator\">=</span> <span class=\"token function\">findClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                 <span class=\"token comment\">// this is the defining class loader; record the stats</span>\n                 <span class=\"token class-name\"><span class=\"token namespace\">sun<span class=\"token punctuation\">.</span>misc<span class=\"token punctuation\">.</span></span>PerfCounter</span><span class=\"token punctuation\">.</span><span class=\"token function\">getParentDelegationTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addTime</span><span class=\"token punctuation\">(</span>t1 <span class=\"token operator\">-</span> t0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token class-name\"><span class=\"token namespace\">sun<span class=\"token punctuation\">.</span>misc<span class=\"token punctuation\">.</span></span>PerfCounter</span><span class=\"token punctuation\">.</span><span class=\"token function\">getFindClassTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addElapsedTimeFrom</span><span class=\"token punctuation\">(</span>t1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token class-name\"><span class=\"token namespace\">sun<span class=\"token punctuation\">.</span>misc<span class=\"token punctuation\">.</span></span>PerfCounter</span><span class=\"token punctuation\">.</span><span class=\"token function\">getFindClasses</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n             <span class=\"token punctuation\">&#125;</span>\n         <span class=\"token punctuation\">&#125;</span>\n         <span class=\"token comment\">// 是否需要解析，默认都是false</span>\n         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n             <span class=\"token function\">resolveClass</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">&#125;</span>\n         <span class=\"token keyword\">return</span> c<span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">&#125;</span>\n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><blockquote>\n<p>如果一个类加载器在接到加载类的请求时，它<strong>首先不会自己尝试去加载这个类</strong>，而是把<strong>这个请求任务委托给父类加载器去完成，依次递归，</strong>如果父类加载器可以完成类加载任务，就成功返回。<strong>只有父类加载器无法完成此加载任务时，才自己去加载</strong></p>\n</blockquote>\n<p><img src=\"http://hyqup-blog-upyun.test.upcdn.net/img/20210601230727770.png\" alt=\"双亲委派模型\"></p>\n<h4 id=\"双亲委派模型优势\"><a href=\"#双亲委派模型优势\" class=\"headerlink\" title=\"双亲委派模型优势\"></a>双亲委派模型优势</h4><ul>\n<li><p>双亲委派保证类加载器，自下而上的委派，又自上而下的加载，<strong>避免类的重复加载</strong>，确保一个类的全局唯一性。保证每一个类在各个类加载器中都是同一个类。</p>\n<p>简言之：当父亲已经加载了该类时，就没有必要子类的ClassLoader 再加载一次</p>\n</li>\n<li><p>保护程序安全，防止核心API被接口重写</p>\n</li>\n</ul>\n<h4 id=\"为什么需要打破双亲委派\"><a href=\"#为什么需要打破双亲委派\" class=\"headerlink\" title=\"为什么需要打破双亲委派\"></a>为什么需要打破双亲委派</h4><p>父类加载器加载范围受限，无法加载的类需要委托子类加载器去完成加载</p>\n<p>直观：JDK的基础类做为典型的API需要去<strong>调用用户代码</strong>，如SPI机制，这种情况就需要打破双亲委派</p>\n<h4 id=\"如何破坏双亲委派\"><a href=\"#如何破坏双亲委派\" class=\"headerlink\" title=\"如何破坏双亲委派\"></a>如何破坏双亲委派</h4><ol>\n<li>方式一：<strong>重写</strong> <strong>loadClass</strong> 方法来<strong>实现用户自定义类加载器</strong></li>\n<li>方式二：<code>SPI</code>，父类委托自类加载器加载Class，以数据库驱动DriverManager为例</li>\n<li>方式三：热部署和不停机更新用到的OSGI技术</li>\n</ol>\n<h3 id=\"自定义类加载器\"><a href=\"#自定义类加载器\" class=\"headerlink\" title=\"自定义类加载器\"></a>自定义类加载器</h3><blockquote>\n<p>自定义Class类继承ClassLoader重写findClass方法</p>\n</blockquote>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ul>\n<li>新建一个Test.java</li>\n<li>编译Test.java到指定目录</li>\n<li>自定义MyClassLoader继承ClassLoader<ul>\n<li>重写findClass</li>\n<li>调用defineClass</li>\n</ul>\n</li>\n<li>测试自定义</li>\n</ul>\n","more":"<h2 id=\"类加载作用\"><a href=\"#类加载作用\" class=\"headerlink\" title=\"类加载作用\"></a>类加载作用</h2><p><strong>ClassLoader</strong></p>\n<p><code>ClassLoader</code>是Java的核心组件，所有的Class都是由ClassLoader进行加载的</p>\n<p><code>ClassLoader</code>负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例，然后交给Java虚拟机进行链接、初始化等操作</p>\n<p><code>ClassLoader</code>在整个装载阶段，只能影响到类的<code>加载</code>（<code>Loading阶段</code>），而无法通过ClassLoader去改变类的<code>链接和初始化</code>行为。至于它是否可以运行，则由Execution Engine决定。</p>\n<h2 id=\"类加载的时机\"><a href=\"#类加载的时机\" class=\"headerlink\" title=\"类加载的时机\"></a>类加载的时机</h2><ul>\n<li>遇到 <code>new</code> 、 <code>getstatic</code> 、 <code>putstatic</code> 和 <code>invokestatic</code> 这四条指令时，如果对应的类没有初始化，则要对对应的类先进行初始化</li>\n<li>使用 java.lang.reflect 包方法时，对类进行<strong>反射调用</strong>的时候</li>\n<li>初始化一个类的时候发现其<strong>父类</strong>还没初始化，要先初始化其<strong>父类</strong></li>\n<li>当虚拟机开始启动时，用户需要指定一个主类（main），虚拟机会先执行这个主类的初始化。</li>\n</ul>\n<h2 id=\"类加载的顺序\"><a href=\"#类加载的顺序\" class=\"headerlink\" title=\"类加载的顺序\"></a>类加载的顺序</h2><p><strong>检查顺序是自底向上</strong>：加载过程中会先检查类是否被已加载，从Custom ClassLoader到BootStrap</p>\n<p>ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有</p>\n<p>ClassLoader加载一次。</p>\n<p><strong>加载的顺序是自顶向下</strong>：也就是由上层来逐层尝试加载此类。</p>\n<h2 id=\"类的加载过程\"><a href=\"#类的加载过程\" class=\"headerlink\" title=\"类的加载过程\"></a>类的加载过程</h2><blockquote>\n<p>类加载主要过程分为 加载、链接、初始化三个阶段，而链接阶段又分为验证 准备 解析</p>\n</blockquote>\n<p><img src=\"http://hyqup-blog-upyun.test.upcdn.net/img/image-20220921210744405.png\" alt=\"image-20220921210744405\"></p>\n<p> ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p>\n<p> <a href=\"https://www.cnblogs.com/aaabbbcccddd/p/14539063.html\">JVM内存模型——堆(heap)、栈(stack)和方法区(method)</a></p>\n<h3 id=\"过程一：Loading（加载）阶段\"><a href=\"#过程一：Loading（加载）阶段\" class=\"headerlink\" title=\"过程一：Loading（加载）阶段\"></a>过程一：Loading（加载）阶段</h3><blockquote>\n<p>将Java类的字节码文件加载到机器内存中，并在内存中构建出java类的原型实例（类模板对象），类结构信息存储到<code>方法区</code></p>\n</blockquote>\n<p><code>类模板对象</code>：本质就是java类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，在JVM运行的时候，就可以通过类模板获取Java类的所有信息，能够对Java类的成员变量进行遍历，也能进行Java 方法的调用</p>\n<p>反射的原理也就JVM在运行期间去拿到类模板信息</p>\n<h3 id=\"过程二：Linking（链接）阶段\"><a href=\"#过程二：Linking（链接）阶段\" class=\"headerlink\" title=\"过程二：Linking（链接）阶段\"></a>过程二：Linking（链接）阶段</h3><h4 id=\"小节一：链接阶段值Verification-验证\"><a href=\"#小节一：链接阶段值Verification-验证\" class=\"headerlink\" title=\"小节一：链接阶段值Verification(验证)\"></a>小节一：链接阶段值Verification(验证)</h4><blockquote>\n<p>目的是<strong>保证加载的字节码是合法、合理并符合规范的</strong></p>\n</blockquote>\n<p>验证的内容则涵盖了类数据信息的<strong>格式验证、语义检查、字节码验证，以及符号引用验证</strong>等</p>\n<h4 id=\"小节二：链接阶段值Preparation-准备\"><a href=\"#小节二：链接阶段值Preparation-准备\" class=\"headerlink\" title=\"小节二：链接阶段值Preparation(准备)\"></a>小节二：链接阶段值Preparation(准备)</h4><blockquote>\n<p><strong>为类的静态变量分配内存，并将其初始化为默认值</strong></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>默认初始值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>byte</td>\n<td>(byte)0</td>\n</tr>\n<tr>\n<td>short</td>\n<td>(short)0</td>\n</tr>\n<tr>\n<td>int</td>\n<td>0</td>\n</tr>\n<tr>\n<td>long</td>\n<td>OL</td>\n</tr>\n<tr>\n<td>float</td>\n<td>0.0f</td>\n</tr>\n<tr>\n<td>double</td>\n<td>0.0</td>\n</tr>\n<tr>\n<td>char</td>\n<td>\\u0000</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>false</td>\n</tr>\n<tr>\n<td>reference</td>\n<td>null</td>\n</tr>\n</tbody></table>\n<h4 id=\"小节三：链接阶段值Resolution-解析\"><a href=\"#小节三：链接阶段值Resolution-解析\" class=\"headerlink\" title=\"小节三：链接阶段值Resolution(解析)\"></a>小节三：链接阶段值Resolution(解析)</h4><blockquote>\n<p><strong>解析阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。</strong></p>\n</blockquote>\n<p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是<strong>在Class类文件中，通过常量池进行了大量的符号引用</strong>。但是在程序实际运行时，只有符号引用是不够的，比如当println()方法被调用时，系统需要明确知道该方法的位置。</p>\n<h3 id=\"过程三：Initialization（初始化）阶段\"><a href=\"#过程三：Initialization（初始化）阶段\" class=\"headerlink\" title=\"过程三：Initialization（初始化）阶段\"></a>过程三：Initialization（初始化）阶段</h3><blockquote>\n<p><em><strong>初始化阶段，简言之，为类的静态变量赋予正确的初始值。</strong></em></p>\n</blockquote>\n<p>1、具体描述</p>\n<p>类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行Java字节码。<strong>（即：到了初始化阶段，才真正开始执行类中定义的Java程序代码。）</strong></p>\n<p>初始化阶段的重要工作是执行类的初始化方法：<code>&lt;clinit&gt;()方法</code></p>\n<p>该方法仅能由<code>Java编译器生成</code>并由<code>JVM调用</code>，程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法，虽然该方法也是由字节码指令所组成。<br>它是由类静态成员的赋值语句以及static语句块合并产生的。 </p>\n<p>clinit编译生成：</p>\n<p>​\t<strong>静态的变量赋值编译才会生成clint方法</strong></p>\n<p>案例说明：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//不会，不是静态，链接(Linking)的准备阶段赋值</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span> <span class=\"token comment\">//不会，没有赋值</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//final 修饰后不是变量是常量所以也不会</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span>  <span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 此时会，静态变量初始化赋值</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"static-final-修饰的一定不会在初始化赋值吗？\"><a href=\"#static-final-修饰的一定不会在初始化赋值吗？\" class=\"headerlink\" title=\"static final 修饰的一定不会在初始化赋值吗？\"></a>static final 修饰的一定不会在初始化赋值吗？</h4><p>eg: public static final Integter INTEGTER_CONSTANT&#x3D;Integer.valueOf(1000);</p>\n<p>因为这里不是常量而是一个方法调用，所以此时也会生成clint</p>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>使用 static+final修饰的成员变量，称为：<code>全局常量</code></p>\n<p>什么时候在<code>链接</code>的准备阶段赋值：给该全局常量赋的值是<code>字面量</code>或者<code>常量</code>，不涉及到<code>方法的调用</code>，其余场景在初始化阶段赋值</p>\n<h3 id=\"类的初始化情况：主动使用-vs被动使用\"><a href=\"#类的初始化情况：主动使用-vs被动使用\" class=\"headerlink\" title=\"类的初始化情况：主动使用 vs被动使用\"></a>类的初始化情况：主动使用 vs被动使用</h3><blockquote>\n<p>Java程序对类的使用分为两种：<strong>主动使用和被动使用</strong>。</p>\n</blockquote>\n<h4 id=\"主动使用\"><a href=\"#主动使用\" class=\"headerlink\" title=\"主动使用\"></a>主动使用</h4><p>Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，<strong>一个类或接口在初次使用前，必须要进行初始化</strong>。这里指的“使用”，是指<code>主动使用</code>，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成）</p>\n<p>1.当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化；</p>\n<p>2.当调用类的静态方法时，即当使用了字节码invokestatic指令；</p>\n<p>3.当使用类、接口的静态字段时（final修饰特殊考虑），比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作）；</p>\n<p>4.当使用java.lang.reflect包中的方法反射类的方法时。比如:Class.forName；</p>\n<p>5.当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；</p>\n<p>6.如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化；</p>\n<p>7.当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类；</p>\n<p>8.当初次调用 MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）；</p>\n<h4 id=\"被动使用\"><a href=\"#被动使用\" class=\"headerlink\" title=\"被动使用\"></a>被动使用</h4><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。<strong>被动使用不会引起类的初始化。</strong></p>\n<ol>\n<li>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化；<br>当通过子类引用父类的静态变量，不会导致子类初始化；</li>\n<li>通过数组定义类引用，不会触发此类的初始化；</li>\n<li>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了；</li>\n<li>调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化；</li>\n</ol>\n<h2 id=\"类的加载器分类\"><a href=\"#类的加载器分类\" class=\"headerlink\" title=\"类的加载器分类\"></a>类的加载器分类</h2><h3 id=\"显示加载与隐士加载\"><a href=\"#显示加载与隐士加载\" class=\"headerlink\" title=\"显示加载与隐士加载\"></a>显示加载与隐士加载</h3><ul>\n<li><strong>显示加载</strong>：指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName（name）或this.getClass().getClassLoader().loadClass()加载class对象</li>\n<li><strong>隐式加载</strong>：不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li>\n</ul>\n<h3 id=\"类加载机制的基本特征\"><a href=\"#类加载机制的基本特征\" class=\"headerlink\" title=\"类加载机制的基本特征\"></a>类加载机制的基本特征</h3><ul>\n<li><strong>双亲委派模型</strong>：</li>\n<li><strong>可见性</strong>：子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。</li>\n<li><strong>单一性</strong>：父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</li>\n</ul>\n<h3 id=\"类加载器分类（两大类）\"><a href=\"#类加载器分类（两大类）\" class=\"headerlink\" title=\"类加载器分类（两大类）\"></a>类加载器分类（两大类）</h3><blockquote>\n<p><strong>引导类加载器(Bootstrap ClassLoader)<strong>和</strong>自定义类加载器(User-Defined ClassLoader)</strong></p>\n</blockquote>\n<p><img src=\"http://file.hyqup.cn/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%A7%8D%E7%B1%BB.png\" alt=\"类加载器种类\"></p>\n<blockquote>\n<p>父子加载类实际上不存在继承关系，而是一种组合关系</p>\n</blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassLoader</span> <span class=\"token punctuation\">&#123;</span>\n\n\t<span class=\"token class-name\">ClassLoader</span> parent<span class=\"token punctuation\">;</span>       父类加载器\n\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">ClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassLoader</span> parent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>parent <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ParentClassLoader</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ClassLoader</span> <span class=\"token punctuation\">&#123;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">ParentClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassLoader</span> parent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n\t<span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ChildClassLoader</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ClassLoader</span> <span class=\"token punctuation\">&#123;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">ChildClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassLoader</span> parent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n\t<span class=\"token comment\">//parent = new ParentClassLoader();</span>\n\n\t<span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"ClassLoader加载逻辑\"><a href=\"#ClassLoader加载逻辑\" class=\"headerlink\" title=\"ClassLoader加载逻辑\"></a>ClassLoader加载逻辑</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> resolve<span class=\"token punctuation\">)</span>\n     <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ClassNotFoundException</span>\n <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token function\">getClassLoadingLock</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n         <span class=\"token comment\">// First, check if the class has already been loaded</span>\n         <span class=\"token comment\">// 查找一下这个类是不是已经加载过了</span>\n         <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> c <span class=\"token operator\">=</span> <span class=\"token function\">findLoadedClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token comment\">//如果没有加载过</span>\n         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n             <span class=\"token keyword\">long</span> t0 <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n             <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n                 <span class=\"token comment\">//parent  每个类加载器都有个父加载器,判断是否有父类加载器，存在则调用父类加载器去加载。双亲委派模型在这</span>\n                 <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                     c <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">.</span><span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n                     <span class=\"token comment\">//如果父类加载器为空，就说明到达顶层也就是BootstrapClassLoader,BootstrapClassLoader属于C/C++编写这里拿不到对象的</span>\n                     c <span class=\"token operator\">=</span> <span class=\"token function\">findBootstrapClassOrNull</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token punctuation\">&#125;</span>\n             <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassNotFoundException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                 <span class=\"token comment\">// ClassNotFoundException thrown if class not found</span>\n                 <span class=\"token comment\">// from the non-null parent class loader</span>\n             <span class=\"token punctuation\">&#125;</span>\n\t<span class=\"token comment\">//如果父类加载都没有加载，则使用当前类加载</span>\n             <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                 <span class=\"token comment\">// If still not found, then invoke findClass in order</span>\n                 <span class=\"token comment\">// to find the class.</span>\n                 <span class=\"token keyword\">long</span> t1 <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token comment\">// findClass用于加载</span>\n                 c <span class=\"token operator\">=</span> <span class=\"token function\">findClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                 <span class=\"token comment\">// this is the defining class loader; record the stats</span>\n                 <span class=\"token class-name\"><span class=\"token namespace\">sun<span class=\"token punctuation\">.</span>misc<span class=\"token punctuation\">.</span></span>PerfCounter</span><span class=\"token punctuation\">.</span><span class=\"token function\">getParentDelegationTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addTime</span><span class=\"token punctuation\">(</span>t1 <span class=\"token operator\">-</span> t0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token class-name\"><span class=\"token namespace\">sun<span class=\"token punctuation\">.</span>misc<span class=\"token punctuation\">.</span></span>PerfCounter</span><span class=\"token punctuation\">.</span><span class=\"token function\">getFindClassTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addElapsedTimeFrom</span><span class=\"token punctuation\">(</span>t1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token class-name\"><span class=\"token namespace\">sun<span class=\"token punctuation\">.</span>misc<span class=\"token punctuation\">.</span></span>PerfCounter</span><span class=\"token punctuation\">.</span><span class=\"token function\">getFindClasses</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n             <span class=\"token punctuation\">&#125;</span>\n         <span class=\"token punctuation\">&#125;</span>\n         <span class=\"token comment\">// 是否需要解析，默认都是false</span>\n         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n             <span class=\"token function\">resolveClass</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">&#125;</span>\n         <span class=\"token keyword\">return</span> c<span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">&#125;</span>\n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><blockquote>\n<p>如果一个类加载器在接到加载类的请求时，它<strong>首先不会自己尝试去加载这个类</strong>，而是把<strong>这个请求任务委托给父类加载器去完成，依次递归，</strong>如果父类加载器可以完成类加载任务，就成功返回。<strong>只有父类加载器无法完成此加载任务时，才自己去加载</strong></p>\n</blockquote>\n<p><img src=\"http://hyqup-blog-upyun.test.upcdn.net/img/20210601230727770.png\" alt=\"双亲委派模型\"></p>\n<h4 id=\"双亲委派模型优势\"><a href=\"#双亲委派模型优势\" class=\"headerlink\" title=\"双亲委派模型优势\"></a>双亲委派模型优势</h4><ul>\n<li><p>双亲委派保证类加载器，自下而上的委派，又自上而下的加载，<strong>避免类的重复加载</strong>，确保一个类的全局唯一性。保证每一个类在各个类加载器中都是同一个类。</p>\n<p>简言之：当父亲已经加载了该类时，就没有必要子类的ClassLoader 再加载一次</p>\n</li>\n<li><p>保护程序安全，防止核心API被接口重写</p>\n</li>\n</ul>\n<h4 id=\"为什么需要打破双亲委派\"><a href=\"#为什么需要打破双亲委派\" class=\"headerlink\" title=\"为什么需要打破双亲委派\"></a>为什么需要打破双亲委派</h4><p>父类加载器加载范围受限，无法加载的类需要委托子类加载器去完成加载</p>\n<p>直观：JDK的基础类做为典型的API需要去<strong>调用用户代码</strong>，如SPI机制，这种情况就需要打破双亲委派</p>\n<h4 id=\"如何破坏双亲委派\"><a href=\"#如何破坏双亲委派\" class=\"headerlink\" title=\"如何破坏双亲委派\"></a>如何破坏双亲委派</h4><ol>\n<li>方式一：<strong>重写</strong> <strong>loadClass</strong> 方法来<strong>实现用户自定义类加载器</strong></li>\n<li>方式二：<code>SPI</code>，父类委托自类加载器加载Class，以数据库驱动DriverManager为例</li>\n<li>方式三：热部署和不停机更新用到的OSGI技术</li>\n</ol>\n<h3 id=\"自定义类加载器\"><a href=\"#自定义类加载器\" class=\"headerlink\" title=\"自定义类加载器\"></a>自定义类加载器</h3><blockquote>\n<p>自定义Class类继承ClassLoader重写findClass方法</p>\n</blockquote>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ul>\n<li>新建一个Test.java</li>\n<li>编译Test.java到指定目录</li>\n<li>自定义MyClassLoader继承ClassLoader<ul>\n<li>重写findClass</li>\n<li>调用defineClass</li>\n</ul>\n</li>\n<li>测试自定义</li>\n</ul>","categories":[{"name":"Java","path":"api/categories/Java.json"},{"name":"JVM","path":"api/categories/JVM.json"}],"tags":[]}